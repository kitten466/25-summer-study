#Java 배열(Array) 정리

## 1. 배열의 개념

- **배열**은 연관된 데이터를 효율적으로 관리하기 위한 데이터 타입이다.
- 여러 개의 같은 타입 데이터를 한 번에 저장하고 그룹핑할 수 있다.
- 파이썬의 리스트와 유사하지만, 한 번 선언하면 크기가 고정된다.

---

## 2. 배열의 선언과 정의

- 배열은 변수와 마찬가지로 타입을 지정해야 하며, 한 번에 여러 값을 저장할 수 있다.

### 선언 방법

```java
// 선언과 동시에 초기화
String[] classGroup = {"A", "B", "C"};

// 선언만 따로
int[] numbers;
numbers = new int;
```

- 대괄호([])를 사용하고, 해당 변수에 여러 데이터를 넣는다.
- 한 배열에는 같은 타입 데이터만 저장할 수 있다.

---

## 3. 배열의 활용 (반복문과 배열)

- 배열의 데이터를 처리하기 위해 주로 **for문**과 함께 사용한다.
- 인덱스는 0부터 시작한다.

```java
for (int i = 0; i < classGroup.length; i++) {
  System.out.println(classGroup[i]);
}
```

- 여러 데이터를 일괄적으로 읽거나 가공할 때 반복문을 활용한다.

---

## 4. 배열의 오류와 한계

- **배열의 크기 초과 접근 시 오류**
  - 배열 길이를 초과하는 인덱스에 접근하면 `ArrayIndexOutOfBoundsException` 예외가 발생한다.
- **고정된 크기**
  - 배열은 선언 시 크기를 반드시 지정하고, 이후에는 변경할 수 없다.
  - 데이터 공간이 남거나 부족하면 효율성이 저하된다.
- **동일 타입만 저장 가능**
  - 배열은 반드시 한 가지 타입의 값만 저장할 수 있다.

---

## 5. 배열의 한계를 보완하는 컬렉션

- 배열의 유연성 한계를 극복하기 위해 Java는 **컬렉션(Collection)** 프레임워크(예: ArrayList 등)를 제공한다.
- 컬렉션은 동적 크기, 타입 유연성 등의 장점이 있어 실제 개발에 많이 사용된다.

---

| 비교 항목 | 배열(Array)                   | ArrayList                 | HashMap                          |
| --------- | ----------------------------- | ------------------------- | -------------------------------- |
| 크기      | 고정(생성 시 변경 불가)       | 가변(추가·삭제 가능)      | 가변(키-값 구조, 추가·삭제 가능) |
| 자료형    | 기본형·참조형 모두 저장 가능  | 참조형(객체)만 저장 가능  | 참조형(객체)만 저장, 키·값 쌍    |
| 인덱싱    | 인덱스로 접근(0부터 시작)     | 인덱스로 접근(0부터 시작) | 키로 직접 접근                   |
| 성능      | 접근 빠름, 삭제/삽입 비효율적 | 접근/삽입/삭제 속도 무난  | 대량 데이터 빠른 탐색/추출       |
| 용도      | 고정 크기의 단순 목록         | 크기가 자주 변하는 목록   | (이름-전화번호) 등 쌍 관리       |

---

## 6. 배열(Array) 예시 코드

```java
// 1~5까지의 숫자를 배열에 저장하고 출력
int[] numbers = new int;
for (int i = 0; i < numbers.length; i++) {
  numbers[i] = i + 1;
}
for (int number : numbers) {
  System.out.println(number);
}
```

- 크기가 고정되어 있고, 요소들은 같은 타입이어야 한다

---

## 7. ArrayList 예시 코드

```java
import java.util.ArrayList;

ArrayList<Integer> numberList = new ArrayList<>();
numberList.add(1);
numberList.add(2);
numberList.add(3);
numberList.add(4);
numberList.add(5);

for (int element : numberList) {
  System.out.println(element);
}
```

- 필요한 만큼 데이터를 자유롭게 추가·삭제 및 관리 가능

---

## 8. HashMap 예시 코드

```java
import java.util.HashMap;
import java.util.Map;

Map<String, Integer> scores = new HashMap<>();
scores.put("홍길동", 85);
scores.put("김철수", 92);

// 값 출력
for (String name : scores.keySet()) {
  System.out.println(name + "의 점수: " + scores.get(name));
}
```

- 키와 값 쌍으로 데이터를 저장하고, 키를 통해 곧바로 값에 접근

---

## 9. 각각 언제, 왜 사용하는가

### 배열(Array)

- **언제 사용?**
  - 데이터 개수가 정해져 있고 변하지 않을 때
  - 같은 타입의 단순 목록을 빠르게 처리해야 할 때
- **이유**
  - 메모리 효율성, 빠른 인덱스 접근(상수시간(데이터 개수와 무관하게 즉시 처리함))
  - 코드가 간결하며 성능이 중요하거나 자주 변하지 않는 데이터에 적합

### ArrayList

- **언제 사용?**
  - 데이터의 개수가 계속 바뀌는 목록
  - 요소의 동적 추가·삭제가 필요한 경우
- **이유**
  - 배열의 고정 크기 한계를 극복, 크기 자동조절
  - 실무에서 “목록”을 주로 다룰 때 더 안전/편리

### HashMap

- **언제 사용?**
  - “이름↔값”, “키↔밸류”처럼 쌍으로 데이터를 저장/검색
  - 중복되지 않는 키 기준으로 빠른 데이터 탐색 필요할 때
- **이유**
  - 다양한 연관 관계(매핑)에 적합
  - 대량 데이터에서 상수시간(데이터 개수와 무관하게 즉시 처리함)에 가까운 빠른 검색·수정

---

## 10. 장단점 요약

| 자료구조    | 장점                              | 단점                              |
| ----------- | --------------------------------- | --------------------------------- |
| 배열(Array) | 빠른 접근, 메모리 절약, 구현 단순 | 크기 고정, 삽입/삭제 비효율       |
| ArrayList   | 크기 자동 조절, 추가/삭제 쉬움    | 내부 복사·삽입 시 속도 저하       |
| HashMap     | 키-값 매핑, 매우 빠른 검색/추출   | 키 중복 불가, 순서 유지 되지 않음 |
